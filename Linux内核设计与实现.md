[TOC]


# Linux内核设计与实现

## 第3章 进程管理

## 第4章 进程调度

## 第5章 系统调用

## 第6章 内核数据结构

## 第7章 中断和中断处理

## 第8章 下半部和推后执行的工作

 ## 第12章 内存管理

> 内核不能像用户空间那样奢侈的使用内存，获取内存币用户空间复杂很多

### 12.1 页

内核把物理页作为内核管理的基本单元，内存管理单元（MMU）是管理内存并将虚拟内存转换为物理内存的硬件，它以页为单位来管理系统中的页表

结构体struct page表示系统中的每个物理页

```c
struct page {
    unsigned long        flags,
    atomic_t             _count,
    atomic_t             _mapcount,
    unsigned long        private,
    struct address_space *mapping,
    pgoff_t              index,
    struct list_head     lru,
    void                 *virtual
};
```

* `flags`域，用来存放页的状态（包括是不是脏的，是不是锁定在内存），每一位单独表示一种状态，至少可以表示32中不同的状态
* `_count`域，存放页的引用计数，-1时内核没有引用该页，在新的内存分配中可以使用。内核调用`page_count()`检查该域，返回0表示页空闲，返回正整数表示正在使用
* 页可以由页缓存使用（此时，mapping域指向页关联的address_space对象），或者作为私有数据（`private`指向），或者作为进程页表中的映射
* `virtual`域，页的虚拟地址，当页在高端内存（不会永久映射到内核空间）中时，这个域为`NULL`

**注意**：

1. `page`结构与物理页相关，并非与虚拟页相关，它仅仅描述当前时刻在相关物理中存放的数据（由于交换等原因，关联的数据继续存在，但是和当前物理页不再关联），它对于页的描述是短暂的
2. 页的拥有者可能是用户空间进程、动态分配的内核数据，静态内核数据或者页高速缓存等

### 12.2 区

Linux主要使用四种区：

* ZONE_DMA，其中包含的页只能进行DMA操作（直接内存访问）
* ZONE_DMA32，和ZONE_DMA类似，不同之处是只能被32位设备访问
* ZONE_NORMAL，包含能够正常映射的页
* ZONE_HIGHMEM，包含“高端内存”，其中的页不能永久地映射到内核空间

> 高端内存，由于一些体系结构的物理内存比虚拟内存大的多，为了充分利用物理内存，将物理内存中的部分区域划分为高端内存，他们不能永久地映射到内核空间，而是动态的映射
>
> 在32位x86体系中，ZONE_HIGHMEM为高于896MB的所有物理内存，其余内存为低端内存，其中ZONE_NORMAL为16MB到896MB的物理内存，ZONE_DMA为小于16MB的物理内存
>
> x86-64系统没有高端内存区

|      区      |      描述      | 物理内存 |
| :----------: | :------------: | :------: |
|   ZONE_DMA   |  DMA使用的页   |  < 16MB  |
| ZONE_NORMAL  | 正常可寻址的页 | 16~896MB |
| ZONE_HIGHMEM |  动态映射的页  | > 896MB  |

每个区使用结构体`zone`表示，具体结构详见**P206**

域说明：

* `lock`域，是一个自旋锁，防止结构被并发访问，这个域只保护结构，不保护驻留在这个区中的页
* `watermark`域，水位值，为每个内存区设置合理的内存消耗基准
* `name`域，表示区的名字，三个区的名字分别为"DMA","Normal","HighMem"	

### 12.3 获得页

* 分配2<sup>order</sup>(1<<order)个**连续**的物理内存页，返回的指针指向第一个页的page结构体

```c
struct page *alloc_pages(gfp_t gfp_mask, unsigned int order);
```

* 将指定的物理页转换为它的逻辑地址（虚拟内存地址），返回的指针指向物理页所在的逻辑地址

```c
void *page_address(struct page *page);
```

* 和`alloc_pages()`功能类似，不过它直接返回请求的第一个页的逻辑地址

```c
unsigned long __get_free_pages(gfp_t fp_mask, unsigned int order)
```

* 只分配一页的函数

```c
struct page *alloc_page(gfp_t gfp_mask);
unsigned long __get_free_page(gfp_t fp_mask)
```

#### 12.3.1 获得填充为0的页

* 分配的所有页内容全为0，返回执行逻辑地址的指针

```c
unsigned long get_zeroed_page(unsigned int gfp_mask)
```

**注意**：为了防止页中留下一般随机的垃圾信息包含一些敏感信息，一般用户空间在获取页的时候，内容最好全部填充为0

#### 12.3.2 释放页

```c
void __free_pages(struct page *page, unsigned int order);
void free_pages(unsigned long addr, unsigned int order);
void free_page(unsigned long addr)
```

**注意**：传递了错误的struct page、地址或者order参数，都可能导致系统崩溃，因为内核是完全相信自己的

### 12.4 kmalloc()

* 以字节为单位分配内存
* 可以获得以字节为单位的一块内核内存

```c
void *kmalloc(size_t size, gfp_t flags);
```

#### 12.4.1 gfp_mask标志

标志分为三类：

* 行为修饰符
* 区修饰符
* 类型修饰符

标志具体说明详见**P209**

#### 12.4.2 kfree()

* 释放由`kmalloc()`分配的内存

```c
void kfree(const void *ptr);
```

### 12.5 vmalloc()

和`kmalloc()`类似，不同之处在于`vmalloc()`分配的内存虚拟内存连续，但是物理内存不一定连续，而`kmalloc()`分配的物理内存也是连续的

`vmalloc()`正是用户空间分配内存的方式：有`malloc()`分配的内存页在进程的虚拟内存中是连续的，但是物理内存不保证连续。大多情况下，只有硬件设备才需要连续的物理内存，他们不理解什么是虚拟内存

### 12.6 slab层

> Linux内核提供slab层（即slab分配器），作为通用数据结构缓存层

#### 12.6.1 slab的设计

> slab层将不同的对象划分为**高速缓存组**，每个高速缓存组存放不同类型的对象，例如，分别存放进程描述符(task_struct结构的空闲链表)，索引节点对象(struct inode)

* `kmalloc()`建立在slab层之上，使用了一组通用高速缓存
* 一般slab仅仅由一页组成，每个高速缓存由多个slab组成
* 每个slab包含一些对象成员，对象指的是被缓存的数据结构
* slab包含三种状态：满、部分满或空

高速缓存使用结构体`kmem_cache`表示，这个结构包括三个链表：`slabs_full`, `slabs_partial`和`slabs_empty`，这些链表包含高速缓存中的所有slab

slab使用slab描述符表示，详见**P216**

```c
struct slab {
    ...
};
```

slab分配器使用`__get_free_pages()`创建新的slab

#### 12.6.2 slab分配器的接口

* 创建一个新的高速缓存
  * `name`：高速缓存的名字
  * `size`：高速缓存中每个元素的大小
  * `align`：slab内第一个对象的偏移量，用来确保在页内进行特定的对齐
  * `flags`：可选的设置项，控制高速缓存的行为，详见**P218**
  * `ctor`：高速缓存的构造函数（Linux的高速缓存不使用构造函数）
  * 返回指向高速缓存的指针
  * 函数调用可能会睡眠，不能再中断上下文使用

```c
struct kmem_cache *kmem_cache_create(const char *name, 
                                    size_t size,
                                    size_t align,
                                    unsigned long flags,
                                    void (*ctor)(void *));
```

* 撤销一个高速缓存（可能睡眠，不能再中断上下文使用）

```c
int kmem_cache_destroy(struct kmem_cache *cachep);
```

**注意**：调用`kmem_cache_destroy`之前要确保两个条件： 

1. 高速缓存中的所有slab为空
2. 在调用此函数过程中不在访问这个高速缓存

* 从已经创建的缓存中分配释放对象，使用示例详见**P219**

```c
void kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);
void kmem_cache_free(struct kmem_cache *cachep, void *objp);
```

### 12.7 栈上的静态分配



## 第13章 虚拟文件系统

> 虚拟文件系统（VFS）： 作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口

### 13.1 通用文件系统接口

> VFS使得用户可以直接使用统一的系统调用，无需考虑具体的文件系统和物理介质

### 13.2 文件系统抽象层

> 内核在底层文件系统接口上建立了一个抽象层，使得Linux能够支持各种文件系统。
>
> 实际文件系统的代码在统一的接口和数据结构下隐藏各自具体的实现细节，它们通过编程提供VFS所期望的抽象接口和数据结构

### 13.3 Unix文件系统

> 四个基本要素：文件、目录项、索引节点和安装点（挂载点）

* 目录项：路径中的每一部分都被称为目录条目，统称为目录项
* 索引节点：Unix系统将文件的相关信息和文件本身这两个概念加以区分（如访问控制权限、大小、创建时间等），文件的相关信息（文件的元数据信息）被存储在一个单独的数据结构，称为索引节点（inode）
* 超级块：是一种包含文件系统控制信息的数据结构，这些信息称为文件系统数据元

![img](https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png)

### 13.4 VFS对象及数据结构

#### 对象类型

VFS的四个对象类型：

* 超级块对象：代表具体的文件系统
* 索引节点对象：代表具体文件
* 目录项对象：代表目录项，是路径的一个组成部分
* 文件对象：代表进程打开的文件

**注意**：VFS将目录作为一个文件来处理，不存在目录对象；目录项不同于目录

#### 操作对象

> 每个对象中都包含一个操作对象，其中描述了内核针对主要对象可以使用的方法

* `super_operations`对象：内核针对特定文件系统调用的方法，如`write_inode(), sync_fs()`
* `inode_operations`对象：内核针对特定文件调用的方法，如`create(), link()`
* `dentry_operations`对象：内核针对特定目录项所能调用的方法，如`d_compare(), d_delete()`
* `file_operations`对象：进程针对已打开文件所能调用的方法，如`read(), write()`

**注意**：操作对象作为结构体，其中包含操作父对象的函数指针，实际的文件系统可以继承VFS提供的通用函数。

### 13.5 超级块对象

> 各种文件系统都必须实现超级块对象，该对象存储特定文件系统的信息，对应于存放在磁盘**特定扇区**中文件系统超级块或者文件系统控制块。（非基于磁盘的文件系统，会在使用现场创建超级块并保存在内存中）

* 超级块对象有`super_block`结构体表示，详见**P231**

**注意**：超级块对象通过`alloc_super()`函数创建并初始化，在安装文件系统时，文件系统会调用这个函数从**磁盘**读取文件系统超级块，并将其中的数据**填充到内存中的超级块对象对应的结构体**中。

### 13.6 超级块操作

> 超级块对象中s_op指针，指向超级块的操作函数表，由`super_operations()`表示

**详见P233**

### 13.7 索引节点对象

> 索引节点对象：包含内核在操作文件系统或者目录时需要的全部信息（对于Unix风格的系统，直接从磁盘的索引节点读入），索引节点对象必须在**内存**中创建。

* 结构体`inode`表示，**详见P235**
* 索引节点代表**普通文件**或者**设备、管道**等特殊文件

### 13.8 索引节点操作

`inode_operation`结构体，**详见P239**

### 13.9 目录项对象

> 每个dentry代表路径中的一个特定部分，比如路径/bin/vi，其中/,bin,vi都是目录项，前两个是**目录**，最后一个是**普通文件**。
>
> **注意**：在路径中，包含普通文件在内，每一项都是目录项对象。

* 结构体`dentry`表示，详见**P239**

* VFS在执行目录项操作时，会现场创建目录项对象

**注意**：目录项对象没有对应的磁盘数据结构，并非保存在磁盘上，`dentry`结构体中没有是否被修改的标志（是否为脏、是否需要写会磁盘）

#### 13.9.1 目录项状态

>  三种状态：被使用、未使用和负状态

* 被使用的目录项：对应一个有效的索引节点，`d_node`指向相应的索引节点，`d_count`代表使用者的数量；不能被丢弃
* 未被使用的目录项：对应有效的索引节点，但是`d_count`为0，仍然指向一个有效对象，被保存在缓存中
* 负状态的目录项：没有对应的有效索引节点，`d_node`为NULL，索引节点已被删除，或者路径不不再正确

**注意**：目录项释放后也可以保存在**slab缓存**中。

#### 13.9.2 目录项缓存

> 内核将目录项对象缓存在目录项缓存dcache中

目录项分为三个部分：

*  **“被使用的”** 目录项链表：索引节点中`i_dentry`链接相关的目录项（一个索引节点可能有多个链接，对应多个目录项），因此用一个链表连接他们
* **“最近被使用的”** 双向链表：包含未被使用和负状态的目录项对象（总是在头部插入新的目录项，需要回收内存时，会再尾部删除旧的目录项）
* **散列表**和相应的**散列函数**：快速将给定路径解析（哈希）成相关的目录项对象

散列表由数组`dentry_hashtable`表示，每个元素指向具有相同键值的目录项组成的链表头指针；散列值有`d_hash`计算（内核系统提供给文件系统**唯一**的散列函数）



**注意**：

1. `dcache`一定意义上提供了对于索引节点的缓存（`icache`），和目录项相关的索引节点对象不会被释放（因为索引节点的使用计数>0），这样确保了索引节点留在内存中
2. 文件访问呈现空间和时间的局部性：时间局部性体现在程序在一段时间内可能会访问相同的文件；空间局部性体现在同一个目录下的文件很可能都被访问。

### 13.10 目录项操作

`dentry_operation`结构体，**详见P241**

### 13.11 文件对象

> 文件对象是已打开的文件在内存中的表示

* 结构体`file`表示

* 由`open()`系统调用创建，`close()撤销`
* 多个进程可以打开同一个文件，所以同一个文件存在多个对应的文件对象
* 文件对象仅仅在观点上代表已打开文件，它反过来指向目录项对象，而目录项对象反过来指向索引节点

**注意**：类似于目录项对象，文件对象没有对应的磁盘数据，通过`file`结构体中`f_dentry`指针指向相关的目录项对象，而目录项对象指向相关的索引节点，索引节点会记录文件是否为脏

### 13.12 文件操作

结构体`file_operation`，详见**P245**，文件相关的操作方法和**系统调用**很类似

* 具体的文件系统可以为每一种操作方法实现各自的代码，如果存在通用操作，则使用通用操作

### 13.13 和文件系统相关的数据结构

#### 结构体 file_system_type

>  描述特定文件系统类型，详见**P248**

* 主要方法`get_sb()`：从磁盘读取超级块，在文件系统安装时，在内存中组装超级块对象
* 剩余的函数描述文件系统的属性
* 每种文件系统，不管有多少实例，都只有一个`file_system_type`结构体

#### 结构体 vfsmount

>  描述安装的文件系统的实例，详见**P248**

* 在文件系统实际被安装时，会有一个`vfsmount`结构体在安装点创建，它代表文件系统的**实例**（也代表一个**安装点**）
* `vfsmount`结构体中维护了各种链表，用于跟踪文件系统和所有安装点之间的关系



### 13.14 和进程相关的数据结构

>  三种结构体：`file_struct`, `fs_struct`, `namespace`

#### 结构体 file_struct

```c
struct file_struct{
    struct file *fd_array[NR_OPEN_DEFAULT]; /*缺省的文件对象数组*/
    struct fdtable *fdt    /*指向其他fd的指针*/
    ...
    
}
```

* 由进程描述符中的`files`指向
* `fd_array`数组指针：指向已打开的文件对象，`NR_OPEN_DEFAULT`默认64，如果进程打开的文件超过64，内核将分配一个新数组，并且将`fdt`指针指向它
* 当访问的文件对象的数量小于64时，执行比较快，因为是对静态数组的操作；如果大于64，内核需要建立新数组，访问速度相对慢一些
* 管理员可以增大`NR_OPEN_DEFAULT`选项优化性能

#### 结构体 fs_struct

* 由进程描述符的`fs`域指向，包含文件系统和进程相关的信息
* 包含进程的当前工作目录（`pwd`）和根目录



#### 结构体 namespace

* 进程描述符的`mmt_namespace`域指向，它使得每个进程在系统中看到唯一的文件系统（唯一的根目录和文件系统结构层次）



**注意**：

1. 对于多数进程，它们的描述符都指向自己独有的`file_struct`和`fs_struct`，除非使用克隆标志`CLONE_FILES`或者`CLONE_FS`创建的进程会共享这两个结构体
2. `namespace`结构体使用方法和前两种结构完全不同，默认情况下，所有进程共享同样的命名空间（都从相同的挂载表中看到同一个文件系统层次结构，除非在`cloen()`操作时使用`CLONE_NEWS`标志，才会给进程一个命名空间结构体的拷贝）

## 第14章 块I/O层

## 第15章 进程地址空间

## 第16章 页高速缓存和页回写





