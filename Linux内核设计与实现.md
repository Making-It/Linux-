[TOC]


# Linux内核设计与实现

## 第13章 虚拟文件系统

> 虚拟文件系统（VFS）： 作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口

### 13.1 通用文件系统接口

> VFS使得用户可以直接使用统一的系统调用，无需考虑具体的文件系统和物理介质

### 13.2 文件系统抽象层

> 内核在底层文件系统接口上建立了一个抽象层，使得Linux能够支持各种文件系统。
>
> 实际文件系统的代码在统一的接口和数据结构下隐藏各自具体的实现细节，它们通过编程提供VFS所期望的抽象接口和数据结构

### 13.3 Unix文件系统

> 四个基本要素：文件、目录项、索引节点和安装点（挂载点）

* 目录项：路径中的每一部分都被称为目录条目，统称为目录项
* 索引节点：Unix系统将文件的相关信息和文件本身这两个概念加以区分（如访问控制权限、大小、创建时间等），文件的相关信息（文件的元数据信息）被存储在一个单独的数据结构，称为索引节点（inode）
* 超级块：是一种包含文件系统控制信息的数据结构，这些信息称为文件系统数据元

![img](https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png)

### 13.4 VFS对象及数据结构

#### 对象类型

VFS的四个对象类型：

* 超级块对象：代表具体的文件系统
* 索引节点对象：代表具体文件
* 目录项对象：代表目录项，是路径的一个组成部分
* 文件对象：代表进程打开的文件

**注意**：VFS将目录作为一个文件来处理，不存在目录对象；目录项不同于目录

#### 操作对象

> 每个对象中都包含一个操作对象，其中描述了内核针对主要对象可以使用的方法

* `super_operations`对象：内核针对特定文件系统调用的方法，如`write_inode(), sync_fs()`
* `inode_operations`对象：内核针对特定文件调用的方法，如`create(), link()`
* `dentry_operations`对象：内核针对特定目录项所能调用的方法，如`d_compare(), d_delete()`
* `file_operations`对象：进程针对已打开文件所能调用的方法，如`read(), write()`

**注意**：操作对象作为结构体，其中包含操作父对象的函数指针，实际的文件系统可以继承VFS提供的通用函数。

### 13.5 超级块对象

> 各种文件系统都必须实现超级块对象，该对象存储特定文件系统的信息，对应于存放在磁盘**特定扇区**中文件系统超级块或者文件系统控制块。（非基于磁盘的文件系统，会在使用现场创建超级块并保存在内存中）

* 超级块对象有`super_block`结构体表示，详见**P231**

**注意**：超级块对象通过`alloc_super()`函数创建并初始化，在安装文件系统时，文件系统会调用这个函数从**磁盘**读取文件系统超级块，并将其中的数据**填充到内存中的超级块对象对应的结构体**中。

### 13.6 超级块操作

> 超级块对象中s_op指针，指向超级块的操作函数表，由`super_operations()`表示

**详见P233**

### 13.7 索引节点对象

> 索引节点对象：包含内核在操作文件系统或者目录时需要的全部信息（对于Unix风格的系统，直接从磁盘的索引节点读入），索引节点对象必须在**内存**中创建。

* 结构体`inode`表示，**详见P235**
* 索引节点代表**普通文件**或者**设备、管道**等特殊文件

### 13.8 索引节点操作

`inode_operation`结构体，**详见P239**

### 13.9 目录项对象

> 每个dentry代表路径中的一个特定部分，比如路径/bin/vi，其中/,bin,vi都是目录项，前两个是**目录**，最后一个是**普通文件**。
>
> **注意**：在路径中，包含普通文件在内，每一项都是目录项对象。

* 结构体`dentry`表示，详见**P239**

* VFS在执行目录项操作时，会现场创建目录项对象

**注意**：目录项对象没有对应的磁盘数据结构，并非保存在磁盘上，`dentry`结构体中没有是否被修改的标志（是否为脏、是否需要写会磁盘）

#### 13.9.1 目录项状态

>  三种状态：被使用、未使用和负状态

* 被使用的目录项：对应一个有效的索引节点，`d_node`指向相应的索引节点，`d_count`代表使用者的数量；不能被丢弃
* 未被使用的目录项：对应有效的索引节点，但是`d_count`为0，仍然指向一个有效对象，被保存在缓存中
* 负状态的目录项：没有对应的有效索引节点，`d_node`为NULL，索引节点已被删除，或者路径不不再正确

**注意**：目录项释放后也可以保存在**slab缓存**中。

#### 13.9.2 目录项缓存

> 内核将目录项对象缓存在目录项缓存dcache中

目录项分为三个部分：

*  **“被使用的”** 目录项链表：索引节点中`i_dentry`链接相关的目录项（一个索引节点可能有多个链接，对应多个目录项），因此用一个链表连接他们
* **“最近被使用的”** 双向链表：包含未被使用和负状态的目录项对象（总是在头部插入新的目录项，需要回收内存时，会再尾部删除旧的目录项）
* **散列表**和相应的**散列函数**：快速将给定路径解析（哈希）成相关的目录项对象

散列表由数组`dentry_hashtable`表示，每个元素指向具有相同键值的目录项组成的链表头指针；散列值有`d_hash`计算（内核系统提供给文件系统**唯一**的散列函数）



**注意**：

1. `dcache`一定意义上提供了对于索引节点的缓存（`icache`），和目录项相关的索引节点对象不会被释放（因为索引节点的使用计数>0），这样确保了索引节点留在内存中
2. 文件访问呈现空间和时间的局部性：时间局部性体现在程序在一段时间内可能会访问相同的文件；空间局部性体现在同一个目录下的文件很可能都被访问。

### 13.10 目录项操作

`dentry_operation`结构体，**详见P241**

### 13.11 文件对象

> 文件对象是已打开的文件在内存中的表示

* 结构体`file`表示

* 由`open()`系统调用创建，`close()撤销`
* 多个进程可以打开同一个文件，所以同一个文件存在多个对应的文件对象
* 文件对象仅仅在观点上代表已打开文件，它反过来指向目录项对象，而目录项对象反过来指向索引节点

**注意**：类似于目录项对象，文件对象没有对应的磁盘数据，通过`file`结构体中`f_dentry`指针指向相关的目录项对象，而目录项对象指向相关的索引节点，索引节点会记录文件是否为脏

### 13.12 文件操作

结构体`file_operation`，详见**P245**，文件相关的操作方法和**系统调用**很类似

* 具体的文件系统可以为每一种操作方法实现各自的代码，如果存在通用操作，则使用通用操作

### 13.13 和文件系统相关的数据结构

#### 结构体 file_system_type

>  描述特定文件系统类型，详见**P248**

* 主要方法`get_sb()`：从磁盘读取超级块，在文件系统安装时，在内存中组装超级块对象
* 剩余的函数描述文件系统的属性
* 每种文件系统，不管有多少实例，都只有一个`file_system_type`结构体

#### 结构体 vfsmount

>  描述安装的文件系统的实例，详见**P248**

* 在文件系统实际被安装时，会有一个`vfsmount`结构体在安装点创建，它代表文件系统的**实例**（也代表一个**安装点**）
* `vfsmount`结构体中维护了各种链表，用于跟踪文件系统和所有安装点之间的关系



### 13.14 和进程相关的数据结构

>  三种结构体：`file_struct`, `fs_struct`, `namespace`

#### 结构体 file_struct

```c
struct file_struct{
    struct file *fd_array[NR_OPEN_DEFAULT]; /*缺省的文件对象数组*/
    struct fdtable *fdt    /*指向其他fd的指针*/
    ...
    
}
```

* 由进程描述符中的`files`指向
* `fd_array`数组指针：指向已打开的文件对象，`NR_OPEN_DEFAULT`默认64，如果进程打开的文件超过64，内核将分配一个新数组，并且将`fdt`指针指向它
* 当访问的文件对象的数量小于64时，执行比较快，因为是对静态数组的操作；如果大于64，内核需要建立新数组，访问速度相对慢一些
* 管理员可以增大`NR_OPEN_DEFAULT`选项优化性能

#### 结构体 fs_struct

* 由进程描述符的`fs`域指向，包含文件系统和进程相关的信息
* 包含进程的当前工作目录（`pwd`）和根目录



#### 结构体 namespace

* 进程描述符的`mmt_namespace`域指向，它使得每个进程在系统中看到唯一的文件系统（唯一的根目录和文件系统结构层次）



**注意**：

1. 对于多数进程，它们的描述符都指向自己独有的`file_struct`和`fs_struct`，除非使用克隆标志`CLONE_FILES`或者`CLONE_FS`创建的进程会共享这两个结构体
2. `namespace`结构体使用方法和前两种结构完全不同，默认情况下，所有进程共享同样的命名空间（都从相同的挂载表中看到同一个文件系统层次结构，除非在`cloen()`操作时使用`CLONE_NEWS`标志，才会给进程一个命名空间结构体的拷贝）





## 第14章 块I/O层



