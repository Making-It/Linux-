[TOC]


# Linux内核设计与实现

## 第3章 进程管理

### 3.1 进程

> 进程：处于执行期的程序以及相关资源（打开的文件、挂起的信号、内核内部数据、处理器状态等）的总称
>
> 线程：是在进程中活动的对象，每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，不是进程
>
> Linux不区分进程和线程，对它来说，线程只不过是一种特殊的进程而已

现代操作系统的两种**虚拟机制**：

* 虚拟处理器：给进程一种假象，让它觉得自己在独享处理器
* 虚拟内存：让进程在分配和管理内存时觉得自己拥有整个系统的内存资源

**注意**：线程之间可以共享虚拟内存，但是都拥有自己的虚拟处理器

### 3.2 进程描述

内核把进程的列表存放在叫做**任务队列**的双向循环链表中。链表中的每一项类型为`task_struct`，称为**进程描述符**的结构，描述了一个具体进程的所有信息

#### 3.2.1 分配进程描述符

Linux通过slab分配器分配`task_struct`结构，这样能够**对象复用**和**缓存着色**。

每个任务的`thread_info`结构在它的内核栈尾端分配，其中`task`域存放的是指向该任务实际`task_struct`的指针

```c
struct thread_info {
	struct task_struct *task;
    struct exec_domain *exec_domain;
    
    ...
};
```

#### 3.2.2 进程描述符的存放

在内核中，访问任务需要获取指向`task_struct`结构的指针，通过`current`宏查找到当前进程的进程描述符，这个查找的**速度**很重要

有的硬件体系结构拿出一个专门的寄存器存放当前进程的`task_struct`指针，而有些像x86的体系结构（寄存器不太富余），就只能在**内核栈的尾部**创建`thread_info`结构，通过计算偏移量间接找到`task_struct`结构

#### 3.2.3 进程状态

进程描述符中的`state`域描述了进程的当前状态。系统中进程的状态包括：

* **TASK_RUNNING**(运行或就绪)：进程是可执行的
* **TASK_INTERRUPTIBLE**(可中断睡眠)
* **TASK_UNINTERRUPTIBLE**(不可中断睡眠)
* **__TASK_TRACED**：被其他进程跟踪的进程，例如ptrace调试的程序
* **__TASK_STOPPED**：被暂停执行的任务，通常在接收到**SIGSTOP**,**SIGTSTP**,**SIGTTIN**,**SIGTTOU**等信号时

#### 3.2.4 设置当前状态

使用`set_task_state(task,state)`函数

#### 3.2.6 进程家族树

所有的进程都是PID为1的init进程的后代，内核在系统启动的最后阶段启动init进程，该进程读取系统的初始化脚本（initsctript）并执行其他的相关程序，最终完成系统启动的整个过程

每个`task_struct`结构都包含一个指向其父进程`task_struct`结构的`parent`指针，还包含一个`children`的子进程链表

### 3.3 进程创建

Unix将进程的创建分解到两个单独的函数中去执行：fork()和exec()

首先，fork()通过拷贝当前进程创建一个子进程，exec()负责读取可执行文件并将其载入地址空间开始运行

#### 3.3.1 写时拷贝

Linux的fork()使用**写时拷贝**页实现，是一种推迟甚至免除拷贝数据的技术，在创建子进程时，内核并不复制整个进程地址空间，而是让父子进程共享一个拷贝，只有在写入的时候，数据才会被复制。在页根本不会被写入的情况下，例如fork()之后马上exec()，进程的地址空间就不用复制了

fork()的实际开销：复制父进程的页表以及给子进程创建唯一的进程描述符

#### 3.3.2 fork()

Linux通过clone()实现fork()，clone()通过一系列参数指明父子进程需要共享的资源。fork(),vfork()和__clone()库函数都根据各自需要的参数标志去调用clone()，然后在clone()中调用do_fork()

do_fork()调用copy_process()函数，然后让进程运行。copy_process()函数的过程：

* 调用`dup_task_struct()`为进程创建一个内核栈、thread_info结构和task_struct，与父进程的值相同，此时父子进程的描述符是相同的
* 检查创建子进程后，当前用户拥有的进程数不超过分配资源限制
* 子进程开始将自己与父进程区分开：进程描述符内的很多成员清0或者初始化，大部分的数据未被修改
* 子进程状态设置为UNINTERRUPTIBAL，保证它不会投入运行
* copy_process()调用copy_flags()更新task_struct的flags成员：其中代表进程是否拥有超级用户权限的PF_SUPERPRIV标志清0，代表进程还没有调用exec()函数的PF_FORKNOEXEC的标志被设置
* 调用alloc_pid()为子进程分配PID
* 根据clone()传递进来的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。（一般这些资源会被进程的**所有线程共享**）
* 最后，copy_process()做扫尾工作并返回一个指向子进程的指针

copy_process()返回到do_fork()函数，如果copy_process()返回成功，新创建的子进程被唤醒并投入运行

**注意**：内核有意选择子进程首先执行，因为一般子进程会调用exec()函数，这样可以避免写时拷贝的额外开销

#### 3.3.3 vfork()

除了**不拷贝父进程的页表项**，vfork()和fork()的功能相同

### 3.4 线程在Linux中的实现

Linux实现线程的机制非常独特，从内核的角度来说，并没有线程这个概念，Linux把所有的**线程当做进程**来实现。线程仅仅被视为一个与其他进程共享某些资源的进程，拥有唯一隶属于自己的`task_struct`。

Windows和Sun Solaris等系统都提供了专门支持线程的机制（将线程称为**轻量级进程**），相较于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。而对于Linux，线程只是**进程间共享资源的一种手段**。

举例说明：对于一个包含四个线程的进程，在提供专门线程支持的系统，通常会有一个包含指向四个不同线程的指针的进程描述符，该描述符负责描述像地址空间、打开的文件等共享资源。而Linux只是创建四个进程并分配四个普通的`task_struct`结构，并指定它们共享某些资源。

#### 3.4.1 创建线程

线程的创建和普通进程类似，只是需要在调用clone()时传递一些参数标志来指明共享的资源：

```c
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)
```

调用的结果和fork()差不多，只是父子进程**共享地址空间、文件系统资源、打开的文件描述符和信号处理程序**

传递给clone()的参数标志决定了**新创建进程的行为方式和父子进程之间共享的资源种类**，详见**P29 表3-1**

#### 3.4.2 内核线程

> 内核线程用于内核在后台执行一些任务，他们是独立运行在内核空间的标准进程
>
> 内核线程和普通进程的区别是：**内核线程没有独立的地址空间**（指向地址空间的mm指针为NULL），它们只在内核空间运行，不切换到用户空间。

例如软中断ksoftirqd和flush都是内核线程的例子

内核是通过从kthreadd内核进程衍生出所有新的内核线程，从现有内核线程创建一个新的内核线程的方法如下：

```c
struct task_struct *thread_create(int (*threadfn)(void *data), void *data, const char namefmt[], ...)
```

新的内核线程是由kthreadd进程通过clone()系统调用创建，它们将运行threadfn函数，传递的参数是data，进程命名为namefmt。

新创建的进程处于不可运行状态，需要通过wake_up_process()唤醒来运行

```c
struct task_struct *thread_run(int (*threadfn)(void *data), void *data, const char namefmt[], ...)
```

`thread_run`方法先调用`thread_run`方法，然后调用`wake_up_process()`

内核线程启动后一直运行直到调用`do_exit()`退出，或者内核的其他部分调用`kthread_stop()`退出（传递给kthread_stop()的参数是kthread_create()返回的task_struct结构地址）

```c
int kthread_stop(struct task_struct *k)
```

### 3.5 进程终结

进程终结的几种情况：

* 显式的调用`exit()`
* 隐式地在某个程序的主函数返回（C语言在main(）函数的返回点防止调用exit()的代码）
* 接收到不能处理也不能忽略的信号或者异常时，被动地终结

不管进程如何终结，大部分都是靠`do_exit()`（定义在kernel/exit.c）来完成，它的主要工作包括：

* 将task_struct的标志成员设置为PF_EXITING
* 调用`del_timer_sync()`删除任一内核定时器，确保没有定时器在排队，且没有定时器处理程序在运行
* 如果BSD记账功能开启，调用`acct_update_intergrals()`来输出记账信息
* 调用`exit_mm()`函数释放进程占用的mm_struct，如果没有别的进程在使用它（没有被共享），就彻底释放它们
* 调用`sem__exit()`函数，如果进程排队等候IPC信号，则它离开队列
* 调用`exit_files()`和`exit_fs()`来分别递减文件描述符和文件系统数据的引用计数，如果引用计数降为0，就可以直接释放
* 接着将存放在task_struct的exit_code成员中的任务退出代码置为`exit()`提供的退出代码。**退出代码存放在这里供父进程检索**
* 调用`exit_notify()`向父进程发送信号，给自己的子进程重新找**养父**（为进程组的其他线程或者init进程），并把进程的状态（task_struct中的exit_state）设置为EXIT_ZOMBIE
* 调用`schedule()`切换到新的进程，因为EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程执行的最后一段代码。`do_exit()`永不返回

至此，与进程相关联的所有资源都释放掉了（假设该进程是这些资源的唯一使用者），进程不可运行且处于EXIT_ZOMBIE状态，他占用的所有内存包括**内核栈、thread_info结构和task_struct结构**。此时存在的唯一目的就是向它的父进程提供信息用于检索，父进程通知内核都是无关的信息后，进程所持有的剩余内存被释放，归还给系统使用

#### 3.5.1 删除进程描述符

在调用`do_exit()`后，进程处于僵死状态不再运行，但是系统保留了它的进程描述符，这样可以**让系统能在进程中杰后仍能获取它的信息**。可以看到，**进程终结时所做的清理工作和进程描述符的删除是分开执行的**，在父进程获得已终结的子进程信息后，通知内核它不关注这些信息后，子进程的task_struct结构被释放

回收子进程状态是通过wait()一族函数实现，他们都是通过唯一的系统调用`wait4()`来实现，它首先会挂起调用它的进程，直到有一个子进程退出，此时函数返回子进程的PID，调用**该函数提供的指针指向子进程的退出代码**

当需要释放进程描述符时，会调用`release_task()`函数，它的工作包括：

* 调用`__exit_signal()`，该函数调用`_unhash_process()`，后者再调用`detach_pid()`从pidhash上删除该进程，同时从任务列表中删除该进程
* `__exit_signal()`函数释放目前僵死进程所使用的所有剩余资源，进行最终统计和记录
* 如果这个进程是进程组的最后一个进程，且领头进程（进程组首进程）已经死掉，那么`release_task()`就通知僵死的领头进程的父进程
* `release_task()`调用`put_task_struct()`释放进程内核栈和thread_info结构所占的内存页，并释放task_struct占用的slab高速缓存

至此，进程描述符和所有进程独享的资源全部释放

#### 3.5.2 孤儿进程造成的进退维谷

当父进程在子进程之前推出时，需要保证子进程找到一个新的父进程，否则这些孤儿进程就会在退出时一直处于僵死状态。

解决方法是：给子进程在当前进程组找一个进程作为父亲，如果不行，就让init进程作为父进程

在`do_exit()`中会调用`exit_nodify()`，该函数调用`forget_original_parent()`，后者再调用`find_new_reaper()`进程寻父过程。

代码中会遍历两个链表：**子进程链表和ptrace子进程链表**，给每个子进程设置新的父进程。

**注意**：当一个进程被跟踪时，它的临时父亲被设置为调试进程，如果他们真正的父进程退出，系统会为它及其兄弟进程找一个父进程。以前的内核版本中需要遍历系统所有的进程来找到这些子进程，现在只需要遍历这个单独ptrace的子进程链表，减轻了遍历的时间消耗

## 第4章 进程调度

> 进程调度程序：在可运行态进程之间分配有限处理器时间资源的**内核子系统**。

### 4.1 多任务

>  多任务操作系统是同时并发地交互执行多个进程的操作系统，能使多个进程处于阻塞或者睡眠状态，这些任务位于内存中，但是并不处于可运行状态，他们利用内核阻塞自己，直到某一时间（键盘输入、网络数据等）发生。

多任务系统分为两类：

* 非抢占式多任务
* 抢占式多任务

Linux提供了抢占式的多任务模式，由调度程序决定什么时候停止一个进程的运行，以便其他进程得到运行机会，这个强制的挂起动作叫做抢占。

时间片：可运行进程在被抢占之前预先设置好的处理器时间段。

非抢占任务模式下，除非进程自己主动停止运行，否则他会一直运行。进程主动挂起自己的操作称为**让步**（yielding）

非抢占任务模式的缺点：调度程序无法对每个进程该执行多长时间做出统一规定，进程独占的CPU时间可能超出预期，另外，一个绝不做出让步的悬挂进程就能使系统崩溃

### 4.2 Linux的进程调度

2.6内核系统开发初期，为了提供对交互程序的调度性能，引入新的调度算法，最为著名的是**反转电梯最后期限调度算法**（RSDL），在2.6.3版本替代了**O(1)调度算法**，最后被称为**完全公平调度算法(CFS)**

### 4.3 策略

#### 4.3.1 I/O消耗型和CPU消耗型的进程

CPU消耗型进程把时间大多用在了执行代码上，不属于I/O驱动类型，从系统响应速度考虑，调度策略往往是降低它们的调度频率，而延长其运行时间

调度策略的主要矛盾是：**进程响应迅速和最大系统利用率（高吞吐量）**

Unix系统的调度程序更倾向于I/O消耗型程序，以提供更好的响应速度。Linux为了保证交互式应用和桌面系统的性能，对进程的响应做了优化（缩短响应时间），更倾向于调度I/O消耗型进程。

#### 4.3.2 进程优先级

调度程序总是选择时间片为用尽而且优先级最高的进程运行

Linux采用了两种不同的优先级范围：

* 第一种用nice值，范围-20~+19，默认值0；越大的nice值优先级越低。相比高nice值（低优先级）的进程，低nice值（高优先级）的进程可以获得更多的处理器时间
* 第二种是实时优先级，数值可配置，默认范围是0~99，数值越大优先级越高。任何实时进程的优先级都比普通进程高，实时优先级和nice优先级处于互不相交的范畴

#### 4.3.3 时间片

调度策略选择合适的时间片并不简单，时间片太短会增加进程切换的处理器消耗，太长会导致系统的交互响应变差

Linux的CFS调度器没有直接分配时间片到进程，它是将**处理器的使用比**划分给进程，所以进程所获得的时间片时间是和**系统负载（系统活跃的进程数）**密切相关的

Linux中新的CFS调度器，它的进程抢占时机取决于**新的可运行程序消耗了多少处理器使用比**。如果消耗的处理器使用比比当前进程小，则新进程投入运行（当前进程被强占），否则，推迟运行。

**总而言之，CFS会先根据进程的nice值预期设定每个进程的cpu使用比，而在进程调度时，需要将新的被唤醒进程实际消耗的cpu使用比和当前进程比较，如果更小，则抢占当前进程，投入运行，否则，推迟运行**

### 4.4 Linux调度算法

#### 4.4.1 调度器类

Linux调度器以模块提供，允许不同类型的进程针对性地选择调度算法，这种模块化结构成为**调度器类**，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。

完全公平调度(CFS)是一个针对普通进程的调度类，称为**SCHED_NORMAL**，具体算法实现定义在文件kernel/sched_fair.c中

#### 4.4.2 Unix系统中的进程调度

传统Unix系统调度：进程启动会有默认的时间片，具有高优先级的进程将运行的更频繁，而且被赋予更多的时间片。存在的问题如下：

* nice映射到时间片，就会将nice单位值对应到处理器的绝对时间，这样将会导致进程切换无法最优化进行，同时会导致进程获得的处理器时间很大程度上取决于其nice初始值。场景实例详见**P40**
* 时间片一般为系统定时器节拍的整数倍，它会随着定时器节拍改变

CFS采用的方法是：**完全摒弃时间片而是分配给进程一个处理器使用比重**，确保了调度中恒定的公平性，切换频率是在动态变化中

#### 4.4.3 公平调度

> 完美的多任务系统：每个进程获得1/*n*的处理器时间（*n*是指可运行进程的数量），同时调度给他们无限小的时间周期（交互性会很好）

CFS的做法：**允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程**，在所有进程总数基础上计算一个进程应该运行多久，不在依靠nice值计算绝对的时间片，而是作为**进程获得的处理器运行比的权重**，越高的nice值获得更低的处理器使用权重。

每个进程按照其权重在全部可运行进程中所占比例的“时间片”来运行，由于越小的调度周期（重新调度所有可运行进程所花的时间）交互性会越好，也就更接近完美的所任务，CFS为调度周期设定一个目标（无限小的调度周期近似值）。

当可运行任务数量区域无限大时，他们所获得的处理器使用比和时间片将趋近于0（这会增加CPU的切换消耗）。因此，CFS引入每个进程获得的时间片底线，称为最小粒度。而当进程数非常多时，由于这个最小粒度的存在，调度周期会比较长，因此CFS并非完美的多任务。

**总之，在CFS中任何进程所获得的的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的，nice值对时间片的作用不再是算数加权，而是几何加权，CFS是近乎完美的多任务**

### 4.5  Linux调度的实现

Linux调度主要关注四个部分：

* 时间记账
* 进程选择
* 调度器入口
* 睡眠和唤醒

#### 4.5.1 时间记账

1. 调度器实体结构

   CFS不再有时间片的概念，但是它会维护每个进程运行的时间记账，需要确保每个进程在分配给它的处理器时间内运行。CFS使用**调度器实体**（文件<linux/sched.h>中的struct_sched_entity中）来追踪进程运行记账

   ```c
   struct sched_entity {
   	struct load_weight load;
       struct rb_node run_node;
       struct list_head group_node;
       ...
       u64 vruntime;
       ...
   };
   ```

   调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符task_struct内

2. 虚拟实时

   vruntime变量存放进程的虚拟运行时间，这个数值的计算是经过所有可运行进程总数的标准化，以ns为单位，与定时器节拍无关

   定义在kernel/sched_fair.h文件中的update_curr()函数实现记账功能，它是系统定时器周期性调用，无论进程是在可运行态还是阻塞状态

   ```c
   static void update_curr(struct cfs_rq *cfs_rq)
   {
   	...
       __update_curr(cfs_rq, curr, delta_exec)
       ...
   }
   ```

#### 4.5.2 进程选择

**CFS**算法调度核心：**当CFS需要选择下一个运行进程时，选择具有最小vruntime的进程**

**CFS**使用红黑树组织可运行进程队列，红黑树的键值为vruntime，检索对应节点的时间复杂度为对数级别

1. 挑选下一个任务

   CFS选择进程的算法为：运行rbtree中最左边叶子结点代表的那个进程。实现的函数是`__pick_next_entity()`，定义在kernel/sched_fair.c中

   ```c
   static struct sched_entity *__pick_next_entity(struct cfs_rq *cfs_rq)
   {
       struct rb_node *left = cfs_rq->rb_leftmost;
       
       if(!left)
           return NULL;
       
       return rb_entry(left, struct sched_entity, run_node)
   }
   ```

   **注意**：如果该函数返回值为NULL，说明树中没有任何节点，代表没有可运行进程，CFS调度器选择idle任务运行

2. 向树中加入进程

   当**进程变为可运行状态（被唤醒）或者通过fork()调用第一次创建进程时**，会将进程加入到rbtree。`enqueue_entity()`函数实现了这个过程，代码详见P45

3. 从树中删除进程

   删除动作发生在**进程阻塞（变为不可运行状态）或者终止（结束运行）**，是由函数`dequeue_entity()`函数完成     

#### 4.5.3 调度器入口

进程调度的入口函数是`schedule()`，定义在kernel/sched.c文件，**它是内核其他部分调用进程调度器的入口**。

`schedule()`通常需要和一个调度类相关联，它会先找到一个最高优先级的调度类，后者要有自己的可运行进程队列，然后这个调度类决定下一个可运行的进程。

因此，`schedule()`函数的逻辑比较简单，它的主要逻辑就是调用`pick_next_task()`，这个函数会以优先级为序，从高到低一次检查每个调度器类，从最高优先级的调度类中选择下一个运行的进程。详细代码见**P48**

```c++
static inline struct task_struct *pick_next_task(struct rq *rq)
{
    ...
}
```

每个调度类都实现了`pick_next_task()`函数，它会返回指向下一个可运行进程的指针，在CFS中`pick_next_task()`会调用`pick_next_entity()`，该函数会调用 [4.5.2节](#4.5.2 进程选择) 提到的`__pick_next_entity()`

**函数优化**：由于CFS是普通进程的调度类，而系统绝大多数进程是普通进程。函数使用了一个小技巧，当所有可运行进程数等于CFS类对应的可运行进程数时，直接返回CFS调度类的下一个运行进程

#### 4.5.4 睡眠和唤醒

睡眠（或阻塞）的进程处于一个特殊的不可运行状态。

进程睡眠时，进程把自己标记为休眠状态，从可执行进程对应的红黑树中移出，放入等待队列，然后调用`schedule()`调度下一个进程；唤醒的过程相反：进程被设置成可执行状态，然后从等待队列移到可执行红黑树中

1. 等待队列

   等待队列是由**等待某些事件发生的进程组成的简单链表**，内核用`wake_queue_head_t`代表等待队列

   进程加入等待队列的详细过程和代码详见**P50**

2. 唤醒

   唤醒操作通过函数`wake_up()`进行，它会唤醒等待队列上的所有进程，它调用函数`tey_to_wake_up()`将进程状态设置为**TASK_RUNNING**，调用`enqueue_task()`将此进程放入红黑树，如果被唤醒的进程比当前正在执行的进程优先级高（这里不是指nice值，而是根据CFS调度的cpu使用比规则得出的结果），还要设置进程的need_resched标志。

   **注意**：通常哪段代码促使等待条件达成，它就要负责调用`wake_up()`函数。例如，当磁盘数据到来时，VFS需要负责对等待队列调用`wake_upe()`。


### 4.6 抢占和上下文切换

上下文切换由定义在kernel/sched.c中的context_switch()函数负责处理。每当一个新的进程被选出来投入运行的时候，schedule()会调用函数context_switch()，后者完成两项工作：

* 调用声明在<asm/mmu_context.h>中的switch_mm()函数，它负责将虚拟内存从上一个进程映射切换到新进程中
* 调用声明在<asm/system.h>的switch_to()，负责从上一个进程的处理器状态切换到新进程的处理器状态，其中包括**保存、恢复栈信息和寄存器信息**

内核提供一个`need_resched`标志标明是否需要重新执行一次调度，2.2以前放在全局变量，2.2~2.4在每个进程的进程描述符中（由于current宏速度很快并且进程描述符通常是在高速缓存中，访问`task_struct`内的数值比全局变量更快），而在2.6版本中，它放在thread_info结构体中，用一个特别的标志变量的一位来表示。

`need_resched`标志被设置的时机：

* 当某个进程应该被抢占时，scheduler_tick()函数会设置这个标志
* 当一个优先级更高的进程进入可运行状态时，try_to_wake_up()也会设置这个标志

然后内核检查该标志，确认被设置后，会调用schedule()切换到一个新进程

#### 4.6.1 用户抢占

内核在中断处理程序或者系统调用返回后，都会检查`need_resched`标志。从中断处理程序或者系统调用返回的返回路径都是跟体系结构相关，在entry.S(包含内核入口和退出的代码)文件通过汇编实现

当内核将返回用户空间的时候，如果`need_resched`标志被设置，会导致schedule()调用，会发生用户抢占

因此，用户抢占发生在以下情况：

* 系统调用返回用户空间时
* 中断处理程序返回用户空间时

#### 4.6.2 内核抢占

>  在没有内核抢占的系统中，调度程序没有办法在一个内核级的任务正在执行时重新调度，内核中的任务以协作方式调度，不具备抢占性，内核代码一直执行到完成（返回用户空间）或者阻塞为止

在2.6版本，Linux内核引入抢占能力，只要重新调度是**安全的**（没有持有锁的情况），内核可以在任何时间抢占正在执行的任务。

在每个进程的thread_info结构中加入preempt_count计数，代表进程使用锁的个数。

* 在中断返回内核空间的时候，会检查need_resched和preempt_count，如果need_resched被设置且preempt_count为0，则可以进行安全的抢占，调度程序schedule()会被调用，否则，中断直接返回当前进程
* 如果进程持有的所有锁被释放，preempt_count会减为0，此时释放锁的代码会检查need_resched标志，如果被设置，则调用schedule()

因此，内核抢占发生在：

* 中断处理程序正在执行，且返回内核空间之前
* 进程在内核空间释放锁的时候
* 内核任务显式的调用schedule()
* 内核中的任务阻塞

### 4.7 实时调度策略

> Linux提供了一种软实时的工作方式
>
> 软实时的定义：内核调度进程尽力使进程在规定时间到来前运行，但是内核不能总是满足这些进程的要求
>
> 硬实时的定义：保证在一定条件下，可以完全满足进程在规定的时间内完成操作

Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，普通的、非实时的调度策略是SCHED_NORMAL。实时策略不被CFS调度器管理，而是被一个特殊的实时调度器管理

SCHED_FIFO实现了**简单的、先入先出的调度算法**，它不使用时间片，SCHED_RR和前者大致相同，不同点在于它使用时间片，是一种**实时轮转调度算法**

## 第5章 系统调用



## 第6章 内核数据结构

## 第7章 中断和中断处理

## 第8章 下半部和推后执行的工作

 ## 第12章 内存管理

> 内核不能像用户空间那样奢侈的使用内存，获取内存币用户空间复杂很多

### 12.1 页

内核把物理页作为内核管理的基本单元，内存管理单元（MMU）是管理内存并将虚拟内存转换为物理内存的硬件，它以页为单位来管理系统中的页表

结构体struct page表示系统中的每个物理页

```c
struct page {
    unsigned long        flags,
    atomic_t             _count,
    atomic_t             _mapcount,
    unsigned long        private,
    struct address_space *mapping,
    pgoff_t              index,
    struct list_head     lru,
    void                 *virtual
};
```

* `flags`域，用来存放页的状态（包括是不是脏的，是不是锁定在内存），每一位单独表示一种状态，至少可以表示32中不同的状态
* `_count`域，存放页的引用计数，-1时内核没有引用该页，在新的内存分配中可以使用。内核调用`page_count()`检查该域，返回0表示页空闲，返回正整数表示正在使用
* 页可以由页缓存使用（此时，mapping域指向页关联的address_space对象），或者作为私有数据（`private`指向），或者作为进程页表中的映射
* `virtual`域，页的虚拟地址，当页在高端内存（不会永久映射到内核空间）中时，这个域为`NULL`

**注意**：

1. `page`结构与物理页相关，并非与虚拟页相关，它仅仅描述当前时刻在相关物理中存放的数据（由于交换等原因，关联的数据继续存在，但是和当前物理页不再关联），它对于页的描述是短暂的
2. 页的拥有者可能是用户空间进程、动态分配的内核数据，静态内核数据或者页高速缓存等

### 12.2 区

Linux主要使用四种区：

* ZONE_DMA，其中包含的页只能进行DMA操作（直接内存访问）
* ZONE_DMA32，和ZONE_DMA类似，不同之处是只能被32位设备访问
* ZONE_NORMAL，包含能够正常映射的页
* ZONE_HIGHMEM，包含“高端内存”，其中的页不能永久地映射到内核空间

> 高端内存，由于一些体系结构的物理内存比虚拟内存大的多，为了充分利用物理内存，将物理内存中的部分区域划分为高端内存，他们不能永久地映射到内核空间，而是动态的映射
>
> 在32位x86体系中，ZONE_HIGHMEM为高于896MB的所有物理内存，其余内存为低端内存，其中ZONE_NORMAL为16MB到896MB的物理内存，ZONE_DMA为小于16MB的物理内存
>
> x86-64系统没有高端内存区

|      区      |      描述      | 物理内存 |
| :----------: | :------------: | :------: |
|   ZONE_DMA   |  DMA使用的页   |  < 16MB  |
| ZONE_NORMAL  | 正常可寻址的页 | 16~896MB |
| ZONE_HIGHMEM |  动态映射的页  | > 896MB  |

每个区使用结构体`zone`表示，具体结构详见**P206**

域说明：

* `lock`域，是一个自旋锁，防止结构被并发访问，这个域只保护结构，不保护驻留在这个区中的页
* `watermark`域，水位值，为每个内存区设置合理的内存消耗基准
* `name`域，表示区的名字，三个区的名字分别为"DMA","Normal","HighMem"	

### 12.3 获得页

* 分配2<sup>order</sup>(1<<order)个**连续**的物理内存页，返回的指针指向第一个页的page结构体

```c
struct page *alloc_pages(gfp_t gfp_mask, unsigned int order);
```

* 将指定的物理页转换为它的逻辑地址（虚拟内存地址），返回的指针指向物理页所在的逻辑地址

```c
void *page_address(struct page *page);
```

* 和`alloc_pages()`功能类似，不过它直接返回请求的第一个页的逻辑地址

```c
unsigned long __get_free_pages(gfp_t fp_mask, unsigned int order)
```

* 只分配一页的函数

```c
struct page *alloc_page(gfp_t gfp_mask);
unsigned long __get_free_page(gfp_t fp_mask)
```

#### 12.3.1 获得填充为0的页

* 分配的所有页内容全为0，返回执行逻辑地址的指针

```c
unsigned long get_zeroed_page(unsigned int gfp_mask)
```

**注意**：为了防止页中留下一般随机的垃圾信息包含一些敏感信息，一般用户空间在获取页的时候，内容最好全部填充为0

#### 12.3.2 释放页

```c
void __free_pages(struct page *page, unsigned int order);
void free_pages(unsigned long addr, unsigned int order);
void free_page(unsigned long addr)
```

**注意**：传递了错误的struct page、地址或者order参数，都可能导致系统崩溃，因为内核是完全相信自己的

### 12.4 kmalloc()

* 以字节为单位分配内存
* 可以获得以字节为单位的一块内核内存

```c
void *kmalloc(size_t size, gfp_t flags);
```

#### 12.4.1 gfp_mask标志

标志分为三类：

* 行为修饰符
* 区修饰符
* 类型修饰符

标志具体说明详见**P209**

#### 12.4.2 kfree()

* 释放由`kmalloc()`分配的内存

```c
void kfree(const void *ptr);
```

### 12.5 vmalloc()

和`kmalloc()`类似，不同之处在于`vmalloc()`分配的内存虚拟内存连续，但是物理内存不一定连续，而`kmalloc()`分配的物理内存也是连续的

`vmalloc()`正是用户空间分配内存的方式：有`malloc()`分配的内存页在进程的虚拟内存中是连续的，但是物理内存不保证连续。大多情况下，只有硬件设备才需要连续的物理内存，他们不理解什么是虚拟内存

### 12.6 slab层

> Linux内核提供slab层（即slab分配器），作为通用数据结构缓存层

#### 12.6.1 slab的设计

> slab层将不同的对象划分为**高速缓存组**，每个高速缓存组存放不同类型的对象，例如，分别存放进程描述符(task_struct结构的空闲链表)，索引节点对象(struct inode)

* `kmalloc()`建立在slab层之上，使用了一组通用高速缓存
* 一般slab仅仅由一页组成，每个高速缓存由多个slab组成
* 每个slab包含一些对象成员，对象指的是被缓存的数据结构
* slab包含三种状态：满、部分满或空

高速缓存使用结构体`kmem_cache`表示，这个结构包括三个链表：`slabs_full`, `slabs_partial`和`slabs_empty`，这些链表包含高速缓存中的所有slab

slab使用slab描述符表示，详见**P216**

```c
struct slab {
    ...
};
```

slab分配器使用`__get_free_pages()`创建新的slab

#### 12.6.2 slab分配器的接口

* 创建一个新的高速缓存
  * `name`：高速缓存的名字
  * `size`：高速缓存中每个元素的大小
  * `align`：slab内第一个对象的偏移量，用来确保在页内进行特定的对齐
  * `flags`：可选的设置项，控制高速缓存的行为，详见**P218**
  * `ctor`：高速缓存的构造函数（Linux的高速缓存不使用构造函数）
  * 返回指向高速缓存的指针
  * 函数调用可能会睡眠，不能再中断上下文使用

```c
struct kmem_cache *kmem_cache_create(const char *name, 
                                    size_t size,
                                    size_t align,
                                    unsigned long flags,
                                    void (*ctor)(void *));
```

* 撤销一个高速缓存（可能睡眠，不能再中断上下文使用）

```c
int kmem_cache_destroy(struct kmem_cache *cachep);
```

**注意**：调用`kmem_cache_destroy`之前要确保两个条件： 

1. 高速缓存中的所有slab为空
2. 在调用此函数过程中不在访问这个高速缓存

* 从已经创建的缓存中分配释放对象，使用示例详见**P219**

```c
void kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);
void kmem_cache_free(struct kmem_cache *cachep, void *objp);
```

### 12.7 栈上的静态分配

> 不同于用户栈，内核栈小而且固定，内核栈一般是两个页大小

#### 12.7.1 单页内核栈

2.6内核之后，引入选项可以设置**单页内核栈**，激活这个选项，每个进程的内核栈只有一页大小

引入的原因有两点：

1. 可以让每个进程减少内存消耗，另外随着机器运行时间增加，寻找两个连续的物理页变得越来越困难
2. 当内核栈使用两页时，中断处理程序使用它所中断进程的内核栈，而当进程使用单页的内核栈时，中断处理程序不放在进程内核栈中，而是放在**中段栈**中。

> 中断栈：为每个进程提供运行中断处理程序的栈，一页大小。

总之，历史上，进程和中断处理程序共享一个栈空间，当1页栈的选项激活之后，中断处理程序获得了自己的栈。

#### 12.7.2 在栈上工作

在任何函数，都要尽量节省内核栈的使用，让所有局部变量大小不要超过几百字节。栈溢出非常危险，所出的数据会直接覆盖紧邻堆栈末端的数据（例如`thread_info`结构就是紧邻进程堆栈末端）。

因此，推荐使用动态分配。

### 12.8 高端内存的映射

#### 12.8.1 永久映射

映射给定的page结构到内核地址空间，使用如下函数

```c
void *kmap(struct page *page);
```

函数在对于高端内存或者低端内存都能使用：

1. 如果page对应低端内存的一页，函数会单纯返回该物理页对应的虚拟地址
2. 如果page对应高端内存页，函数会建立一个永久映射，在返回对应的虚拟地址
3. 函数可以睡眠，只能在进程上下文中使用

当不再需要高端内存中的这一个页时，使用如下函数解除映射

```c
void kunmap(struct page *page);
```

#### 12.8.2 临时映射

>  当必须创建映射而上下文不能睡眠是，内核提供了临时映射（原子映射）

临时映射可以用在像中断上下文一样的不能睡眠的地方，使用如下函数建立心是映射：

```c
void *kmap_atomic(struct page *page, enum km_type type);
```

* 函数禁止了内核抢占（因为映射对每个处理器都是唯一的？？？）

### 12.9 每个CPU的分配

> SMP定义：一个操作系统的实例可以同时管理所有CPU内核，且应用并不绑定某一个内核。
>
> 支持SMP的操作系统使用每个CPU上的数据，对于给定的处理器其数据是唯一的，每个CPU的数据存放在一个数组中，数组的每一个元素对应一个存在的处理器

```c
unsigned long my_percpu[NR_CPUS];
```

访问cpu数据过程：

```c
int cpu;

cpu = get_cpu();  //获取当前CPU，并且禁止内核抢占
data = my_percpu[cpu];
....       // 使用data的过程
put_cpu();
```

代码中没有出现锁，因为数据对当前处理器是唯一的，没有其他处理器可以接触这个数据，没有多个处理器并发访问的问题，但是会有内核抢占的问题：

1. 如果代码被其他处理器抢占并重新调度，这是cpu变量data会变成无效，因为它对应了错误的处理器
2. 如果另一个进程抢占了代码，有可能在一个处理器上并发访问data数据的问题

因此，在获取当前cpu时，就已经禁止了内核抢占。

### 12.10 新的每个CPU接口

>  描述了一些为每个CPU分配内存的接口，详见**P223**

### 12.11 使用每个CPU数据的原因

使用每个CPU的好处有：

1. 减少数据锁定，每个处理器访问每个CPU数据，不用加锁
2. 使用每个CPU数据大大减少了缓存失效，失效发生在处理器试图使他们的缓存保持同步时，如果一个处理器操作数据时，该数据又存放在其他处理器缓存中，那么存放该数据的那个处理器必须刷新或者清理自己的缓存，频繁的缓存失效会造成**缓存抖动**

而使用每个CPU数据唯一的要求是需要**禁止内核抢占**

## 第13章 虚拟文件系统

> 虚拟文件系统（VFS）： 作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口

### 13.1 通用文件系统接口

> VFS使得用户可以直接使用统一的系统调用，无需考虑具体的文件系统和物理介质

### 13.2 文件系统抽象层

> 内核在底层文件系统接口上建立了一个抽象层，使得Linux能够支持各种文件系统。
>
> 实际文件系统的代码在统一的接口和数据结构下隐藏各自具体的实现细节，它们通过编程提供VFS所期望的抽象接口和数据结构

### 13.3 Unix文件系统

> 四个基本要素：文件、目录项、索引节点和安装点（挂载点）

* 目录项：路径中的每一部分都被称为目录条目，统称为目录项
* 索引节点：Unix系统将文件的相关信息和文件本身这两个概念加以区分（如访问控制权限、大小、创建时间等），文件的相关信息（文件的元数据信息）被存储在一个单独的数据结构，称为索引节点（inode）
* 超级块：是一种包含文件系统控制信息的数据结构，这些信息称为文件系统数据元

![img](https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png)

### 13.4 VFS对象及数据结构

#### 对象类型

VFS的四个对象类型：

* 超级块对象：代表具体的文件系统
* 索引节点对象：代表具体文件
* 目录项对象：代表目录项，是路径的一个组成部分
* 文件对象：代表进程打开的文件

**注意**：VFS将目录作为一个文件来处理，不存在目录对象；目录项不同于目录

#### 操作对象

> 每个对象中都包含一个操作对象，其中描述了内核针对主要对象可以使用的方法

* `super_operations`对象：内核针对特定文件系统调用的方法，如`write_inode(), sync_fs()`
* `inode_operations`对象：内核针对特定文件调用的方法，如`create(), link()`
* `dentry_operations`对象：内核针对特定目录项所能调用的方法，如`d_compare(), d_delete()`
* `file_operations`对象：进程针对已打开文件所能调用的方法，如`read(), write()`

**注意**：操作对象作为结构体，其中包含操作父对象的函数指针，实际的文件系统可以继承VFS提供的通用函数。

### 13.5 超级块对象

> 各种文件系统都必须实现超级块对象，该对象存储特定文件系统的信息，对应于存放在磁盘**特定扇区**中文件系统超级块或者文件系统控制块。（非基于磁盘的文件系统，会在使用现场创建超级块并保存在内存中）

* 超级块对象有`super_block`结构体表示，详见**P231**

**注意**：超级块对象通过`alloc_super()`函数创建并初始化，在安装文件系统时，文件系统会调用这个函数从**磁盘**读取文件系统超级块，并将其中的数据**填充到内存中的超级块对象对应的结构体**中。

### 13.6 超级块操作

> 超级块对象中s_op指针，指向超级块的操作函数表，由`super_operations()`表示

**详见P233**

### 13.7 索引节点对象

> 索引节点对象：包含内核在操作文件系统或者目录时需要的全部信息（对于Unix风格的系统，直接从磁盘的索引节点读入），索引节点对象必须在**内存**中创建。

* 结构体`inode`表示，**详见P235**
* 索引节点代表**普通文件**或者**设备、管道**等特殊文件

### 13.8 索引节点操作

`inode_operation`结构体，**详见P239**

### 13.9 目录项对象

> 每个dentry代表路径中的一个特定部分，比如路径/bin/vi，其中/,bin,vi都是目录项，前两个是**目录**，最后一个是**普通文件**。
>
> **注意**：在路径中，包含普通文件在内，每一项都是目录项对象。

* 结构体`dentry`表示，详见**P239**

* VFS在执行目录项操作时，会现场创建目录项对象

**注意**：目录项对象没有对应的磁盘数据结构，并非保存在磁盘上，`dentry`结构体中没有是否被修改的标志（是否为脏、是否需要写会磁盘）

#### 13.9.1 目录项状态

>  三种状态：被使用、未使用和负状态

* 被使用的目录项：对应一个有效的索引节点，`d_node`指向相应的索引节点，`d_count`代表使用者的数量；不能被丢弃
* 未被使用的目录项：对应有效的索引节点，但是`d_count`为0，仍然指向一个有效对象，被保存在缓存中
* 负状态的目录项：没有对应的有效索引节点，`d_node`为NULL，索引节点已被删除，或者路径不不再正确

**注意**：目录项释放后也可以保存在**slab缓存**中。

#### 13.9.2 目录项缓存

> 内核将目录项对象缓存在目录项缓存dcache中

目录项分为三个部分：

*  **“被使用的”** 目录项链表：索引节点中`i_dentry`链接相关的目录项（一个索引节点可能有多个链接，对应多个目录项），因此用一个链表连接他们
* **“最近被使用的”** 双向链表：包含未被使用和负状态的目录项对象（总是在头部插入新的目录项，需要回收内存时，会再尾部删除旧的目录项）
* **散列表**和相应的**散列函数**：快速将给定路径解析（哈希）成相关的目录项对象

散列表由数组`dentry_hashtable`表示，每个元素指向具有相同键值的目录项组成的链表头指针；散列值有`d_hash`计算（内核系统提供给文件系统**唯一**的散列函数）



**注意**：

1. `dcache`一定意义上提供了对于索引节点的缓存（`icache`），和目录项相关的索引节点对象不会被释放（因为索引节点的使用计数>0），这样确保了索引节点留在内存中
2. 文件访问呈现空间和时间的局部性：时间局部性体现在程序在一段时间内可能会访问相同的文件；空间局部性体现在同一个目录下的文件很可能都被访问。

### 13.10 目录项操作

`dentry_operation`结构体，**详见P241**

### 13.11 文件对象

> 文件对象是已打开的文件在内存中的表示

* 结构体`file`表示

* 由`open()`系统调用创建，`close()撤销`
* 多个进程可以打开同一个文件，所以同一个文件存在多个对应的文件对象
* 文件对象仅仅在观点上代表已打开文件，它反过来指向目录项对象，而目录项对象反过来指向索引节点

**注意**：类似于目录项对象，文件对象没有对应的磁盘数据，通过`file`结构体中`f_dentry`指针指向相关的目录项对象，而目录项对象指向相关的索引节点，索引节点会记录文件是否为脏

### 13.12 文件操作

结构体`file_operation`，详见**P242**，文件相关的操作方法和**系统调用**很类似

* 具体的文件系统可以为每一种操作方法实现各自的代码，如果存在通用操作，则使用通用操作

### 13.13 和文件系统相关的数据结构

#### 结构体 file_system_type

>  描述特定文件系统类型，详见**P248**

* 主要方法`get_sb()`：从磁盘读取超级块，在文件系统安装时，在内存中组装超级块对象
* 剩余的函数描述文件系统的属性
* 每种文件系统，不管有多少实例，都只有一个`file_system_type`结构体

#### 结构体 vfsmount

>  描述安装的文件系统的实例，详见**P248**

* 在文件系统实际被安装时，会有一个`vfsmount`结构体在安装点创建，它代表文件系统的**实例**（也代表一个**安装点**）
* `vfsmount`结构体中维护了各种链表，用于跟踪文件系统和所有安装点之间的关系



### 13.14 和进程相关的数据结构

>  三种结构体：`file_struct`, `fs_struct`, `namespace`

#### 结构体 file_struct

```c
struct file_struct{
    struct file *fd_array[NR_OPEN_DEFAULT]; /*缺省的文件对象数组*/
    struct fdtable *fdt    /*指向其他fd的指针*/
    ...
    
}
```

* 由进程描述符中的`files`指向
* `fd_array`数组指针：指向已打开的文件对象，`NR_OPEN_DEFAULT`默认64，如果进程打开的文件超过64，内核将分配一个新数组，并且将`fdt`指针指向它
* 当访问的文件对象的数量小于64时，执行比较快，因为是对静态数组的操作；如果大于64，内核需要建立新数组，访问速度相对慢一些
* 管理员可以增大`NR_OPEN_DEFAULT`选项优化性能

#### 结构体 fs_struct

* 由进程描述符的`fs`域指向，包含文件系统和进程相关的信息
* 包含进程的当前工作目录（`pwd`）和根目录



#### 结构体 namespace

* 进程描述符的`mmt_namespace`域指向，它使得每个进程在系统中看到唯一的文件系统（唯一的根目录和文件系统结构层次）



**注意**：

1. 对于多数进程，它们的描述符都指向自己独有的`file_struct`和`fs_struct`，除非使用克隆标志`CLONE_FILES`或者`CLONE_FS`创建的进程会共享这两个结构体
2. `namespace`结构体使用方法和前两种结构完全不同，默认情况下，所有进程共享同样的命名空间（都从相同的挂载表中看到同一个文件系统层次结构，除非在`cloen()`操作时使用`CLONE_NEWS`标志，才会给进程一个命名空间结构体的拷贝）

## 第14章 块I/O层

## 第15章 进程地址空间

## 第16章 页高速缓存和页回写





